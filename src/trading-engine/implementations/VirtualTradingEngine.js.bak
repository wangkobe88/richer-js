/**
 * è™šæ‹Ÿäº¤æ˜“å¼•æ“ - ç®€åŒ–ç‰ˆ
 * ç”¨äº fourmeme äº¤æ˜“å®éªŒçš„è™šæ‹Ÿäº¤æ˜“æ¨¡æ‹Ÿ
 */

const { ITradingEngine, TradingMode, EngineStatus } = require('../interfaces/ITradingEngine');
const { Experiment, Trade, TradeSignal, TradeStatus } = require('../entities');
const { ExperimentFactory } = require('../factories/ExperimentFactory');
const { ExperimentDataService } = require('../../web/services/ExperimentDataService');
const { dbManager } = require('../../services/dbManager');
const Logger = require('../../services/logger');

// æ–°å¢å¯¼å…¥
const TokenPool = require('../../core/token-pool');
const FourmemeCollector = require('../../collectors/fourmeme-collector');
const { StrategyEngine } = require('../../strategies/StrategyEngine');
const { AveKlineAPI } = require('../../core/ave-api');
const { RSIIndicator } = require('../../indicators/RSIIndicator');
const { RoundSummary } = require('../utils/RoundSummary');

// åŠ è½½é…ç½®
const config = require('../../../config/default.json');

/**
 * è™šæ‹Ÿäº¤æ˜“å¼•æ“
 * @class
 * @implements ITradingEngine
 */
class VirtualTradingEngine {
  /**
   * æ„é€ å‡½æ•°
   * @param {Object} config - é…ç½®å¯¹è±¡
   * @param {number} config.initialBalance - åˆå§‹ä½™é¢ (é»˜è®¤ 100 BNB)
   */
  constructor(config = {}) {
    this._id = `virtual_${Date.now()}`;
    this._name = 'Fourmeme Virtual Trading Engine';
    this._mode = TradingMode.VIRTUAL;
    this._status = EngineStatus.STOPPED;

    // å®éªŒç›¸å…³
    this._experiment = null;
    this._experimentId = null;

    // è™šæ‹Ÿèµ„é‡‘ç®¡ç†
    this.initialBalance = config.initialBalance || 100; // BNB
    this.currentBalance = this.initialBalance;
    this.holdings = new Map(); // tokenAddress -> { amount, avgBuyPrice }

    // ç»Ÿè®¡ä¿¡æ¯
    this.metrics = {
      totalTrades: 0,
      successfulTrades: 0,
      failedTrades: 0,
      totalSignals: 0,
      executedSignals: 0
    };

    // æœåŠ¡
    this.dataService = new ExperimentDataService();
    this.logger = new Logger({ dir: './logs', experimentId: null }); // åˆå§‹æ—  experimentIdï¼Œå°†åœ¨ initialize ä¸­è®¾ç½®

    // æ•°æ®åº“å®¢æˆ·ç«¯
    this.supabase = dbManager.getClient();

    // æ–°å¢ï¼šç›‘æ§å¾ªç¯ç›¸å…³
    this._tokenPool = null;
    this._fourmemeCollector = null;
    this._strategyEngine = null;
    this._aveApi = null;
    this._rsiIndicator = null;
    this._monitoringTimer = null;
    this._loopCount = 0;
    this._roundSummary = null;

    console.log(`ğŸ® è™šæ‹Ÿäº¤æ˜“å¼•æ“å·²åˆ›å»º: ${this.id}, åˆå§‹ä½™é¢: ${this.initialBalance} BNB`);
  }

  // Getter æ–¹æ³• - è¿”å›ç§æœ‰å±æ€§
  get id() { return this._id; }
  get name() { return this._name; }
  get mode() { return this._mode; }
  get status() { return this._status; }
  get experiment() { return this._experiment; }

  /**
   * åˆå§‹åŒ–å¼•æ“
   * @param {Experiment|string} experimentOrId - å®éªŒå®ä½“æˆ–å®éªŒID
   * @returns {Promise<void>}
   */
  async initialize(experimentOrId) {
    try {
      // åŠ è½½æˆ–åˆ›å»ºå®éªŒ
      if (typeof experimentOrId === 'string') {
        // åŠ è½½ç°æœ‰å®éªŒ
        const factory = ExperimentFactory.getInstance();
        this._experiment = await factory.load(experimentOrId);
        if (!this._experiment) {
          throw new Error(`å®éªŒä¸å­˜åœ¨: ${experimentOrId}`);
        }
      } else if (experimentOrId instanceof Experiment) {
        // ä½¿ç”¨æä¾›çš„å®éªŒ
        this._experiment = experimentOrId;
      } else {
        throw new Error('æ— æ•ˆçš„å®éªŒå‚æ•°');
      }

      this._experimentId = this._experiment.id;

      // æ›´æ–° logger çš„ experimentId
      this.logger.experimentId = this._experimentId;

      // åˆå§‹åŒ– RoundSummary
      this._roundSummary = new RoundSummary(this._experimentId, this.logger);

      // ä»å®éªŒé…ç½®ä¸­è·å–åˆå§‹ä½™é¢
      if (this._experiment.config?.virtual?.initialBalance) {
        this.initialBalance = this._experiment.config.virtual.initialBalance;
        this.currentBalance = this.initialBalance;
      }

      // åŠ è½½æŒä»“æ•°æ®
      await this._loadHoldings();

      // æ–°å¢ï¼šåˆå§‹åŒ–ç›‘æ§æ¨¡å—
      await this._initializeMonitoring();

      this._status = EngineStatus.STOPPED;

      console.log(`âœ… è™šæ‹Ÿäº¤æ˜“å¼•æ“åˆå§‹åŒ–å®Œæˆ: å®éªŒ ${this._experimentId}`);
      this.logger.info(this._experimentId, 'VirtualTradingEngine', 'å¼•æ“åˆå§‹åŒ–å®Œæˆ', {
        initialBalance: this.initialBalance,
        currentBalance: this.currentBalance,
        holdingsCount: this.holdings.size
      });

    } catch (error) {
      console.error('âŒ è™šæ‹Ÿäº¤æ˜“å¼•æ“åˆå§‹åŒ–å¤±è´¥:', error.message);
      this._status = EngineStatus.ERROR;
      throw error;
    }
  }

  /**
   * åˆå§‹åŒ–ç›‘æ§æ¨¡å—
   * @private
   * @returns {Promise<void>}
   */
  async _initializeMonitoring() {
    // 1. åˆå§‹åŒ–ä»£å¸æ± 
    this._tokenPool = new TokenPool(this.logger);
    console.log(`âœ… ä»£å¸æ± åˆå§‹åŒ–å®Œæˆ`);

    // 2. åˆå§‹åŒ–AVE API
    const apiKey = process.env.AVE_API_KEY;
    this._aveApi = new AveKlineAPI(
      config.ave.apiUrl,
      config.ave.timeout,
      apiKey
    );
    console.log(`âœ… AVE APIåˆå§‹åŒ–å®Œæˆ`);

    // 3. åˆå§‹åŒ–æ”¶é›†å™¨
    this._fourmemeCollector = new FourmemeCollector(
      config,
      this.logger,
      this._tokenPool
    );
    console.log(`âœ… Fourmemeæ”¶é›†å™¨åˆå§‹åŒ–å®Œæˆ`);

    // 4. åˆå§‹åŒ–RSIæŒ‡æ ‡
    this._rsiIndicator = new RSIIndicator({
      period: 14,
      smoothingPeriod: 9,
      smoothingType: 'EMA'
    });
    console.log(`âœ… RSIæŒ‡æ ‡åˆå§‹åŒ–å®Œæˆ`);

    // 5. åˆå§‹åŒ–ç­–ç•¥å¼•æ“
    const strategies = this._buildStrategyConfig();
    this._strategyEngine = new StrategyEngine({ strategies });

    // æ„å»ºå¯ç”¨å› å­é›†åˆ
    const availableFactorIds = new Set([
      'age', 'currentPrice', 'buyPrice', 'holdDuration',
      'profitPercent', 'rsi'
    ]);

    // åŠ è½½ç­–ç•¥ï¼ˆå¸¦éªŒè¯ï¼‰
    this._strategyEngine.loadStrategies(strategies, availableFactorIds);
    console.log(`âœ… ç­–ç•¥å¼•æ“åˆå§‹åŒ–å®Œæˆï¼ŒåŠ è½½äº† ${this._strategyEngine.getStrategyCount()} ä¸ªç­–ç•¥`);
  }

  /**
   * å¯åŠ¨å¼•æ“
   * @returns {Promise<void>}
   */
  async start() {
    if (this._status === EngineStatus.RUNNING) {
      console.warn('âš ï¸ å¼•æ“å·²åœ¨è¿è¡Œ');
      return;
    }

    this._status = EngineStatus.RUNNING;

    // æ›´æ–°å®éªŒçŠ¶æ€
    if (this._experiment) {
      this._experiment.start();
      const factory = ExperimentFactory.getInstance();
      await factory.updateStatus(this._experimentId, 'running');
    }

    // æ–°å¢ï¼šå¯åŠ¨æ”¶é›†å™¨ï¼ˆåå°æ¯10ç§’æ”¶é›†æ–°ä»£å¸ï¼‰
    this._fourmemeCollector.start();
    console.log(`ğŸ”„ Fourmemeæ”¶é›†å™¨å·²å¯åŠ¨ (${config.collector.interval}msé—´éš”)`);
    this.logger.info(this._experimentId, 'VirtualTradingEngine', 'Fourmemeæ”¶é›†å™¨å·²å¯åŠ¨');

    // æ–°å¢ï¼šå¯åŠ¨ç›‘æ§å¾ªç¯
    this._startMonitoringLoop();

    console.log(`ğŸš€ è™šæ‹Ÿäº¤æ˜“å¼•æ“å·²å¯åŠ¨: å®éªŒ ${this._experimentId}`);
    this.logger.info(this._experimentId, 'VirtualTradingEngine', 'å¼•æ“å·²å¯åŠ¨');
  }

  /**
   * åœæ­¢å¼•æ“
   * @returns {Promise<void>}
   */
  async stop() {
    if (this._status === EngineStatus.STOPPED) {
      console.warn('âš ï¸ å¼•æ“å·²åœæ­¢');
      return;
    }

    this._status = EngineStatus.STOPPED;

    // æ–°å¢ï¼šåœæ­¢æ”¶é›†å™¨
    if (this._fourmemeCollector) {
      this._fourmemeCollector.stop();
      console.log(`â¹ï¸ Fourmemeæ”¶é›†å™¨å·²åœæ­¢`);
    }

    // æ–°å¢ï¼šåœæ­¢ç›‘æ§å¾ªç¯
    if (this._monitoringTimer) {
      clearInterval(this._monitoringTimer);
      this._monitoringTimer = null;
      console.log(`â¹ï¸ ç›‘æ§å¾ªç¯å·²åœæ­¢`);
    }

    // æ›´æ–°å®éªŒçŠ¶æ€
    if (this._experiment) {
      this._experiment.stop('stopped');
      const factory = ExperimentFactory.getInstance();
      await factory.updateStatus(this._experimentId, 'stopped');
    }

    console.log(`ğŸ›‘ è™šæ‹Ÿäº¤æ˜“å¼•æ“å·²åœæ­¢: å®éªŒ ${this._experimentId}`);
    this.logger.info(this._experimentId, 'VirtualTradingEngine', 'å¼•æ“å·²åœæ­¢', {
      metrics: this.metrics,
      loopCount: this._loopCount
    });
  }

  /**
   * å¯åŠ¨ç›‘æ§å¾ªç¯
   * @private
   */
  _startMonitoringLoop() {
    const interval = config.monitor.interval || 10000; // é»˜è®¤10ç§’

    this._monitoringTimer = setInterval(async () => {
      await this._monitoringCycle();
    }, interval);

    console.log(`ğŸ”„ ç›‘æ§å¾ªç¯å·²å¯åŠ¨ï¼Œé—´éš”: ${interval}ms`);
    this.logger.info(this._experimentId, 'VirtualTradingEngine', 'ç›‘æ§å¾ªç¯å·²å¯åŠ¨', {
      interval: interval
    });
  }

  /**
   * ç›‘æ§å¾ªç¯ä¸»é€»è¾‘
   * @private
   * @returns {Promise<void>}
   */
  async _monitoringCycle() {
    this._loopCount++;
    const startTime = Date.now();

    // å¼€å§‹æ–°è½®æ¬¡è®°å½•
    if (this._roundSummary) {
      this._roundSummary.startRound(this._loopCount);
    }

    this.logger.info(this._experimentId, 'MonitoringCycle',
      `å¼€å§‹ç¬¬ ${this._loopCount} è½®ç›‘æ§`);

    try {
      // è®°å½•æ”¶é›†å™¨ç»Ÿè®¡
      if (this._roundSummary) {
        const collectorStats = this._fourmemeCollector.getStats();
        this._roundSummary.recordCollectorStats({
          lastFetched: collectorStats.totalCollected - (collectorStats.lastCollectionTime ? 0 : collectorStats.totalCollected),
          lastAdded: 0, // å°†åœ¨å¤„ç†æ—¶æ›´æ–°
          lastSkipped: collectorStats.totalSkipped,
          poolSize: collectorStats.poolSize,
          monitoringCount: collectorStats.monitoringCount,
          boughtCount: collectorStats.boughtCount
        });
      }

      // 1. è·å–æ± ä¸­éœ€è¦ç›‘æ§çš„ä»£å¸
      const tokens = this._tokenPool.getMonitoringTokens();
      this.logger.debug(this._experimentId, 'MonitoringCycle',
        `æ± ä¸­ç›‘æ§ä»£å¸æ•°: ${tokens.length} (monitoring+bought)`);

      if (tokens.length === 0) {
        this.logger.debug(this._experimentId, 'MonitoringCycle',
          `ç¬¬ ${this._loopCount} è½®ç›‘æ§: æ— ä»£å¸éœ€è¦å¤„ç†`);
        // å³ä½¿æ²¡æœ‰ä»£å¸ï¼Œä¹Ÿè¾“å‡ºæ‘˜è¦ï¼ˆæ˜¾ç¤ºæ”¶é›†å™¨ç»Ÿè®¡ï¼‰
        if (this._roundSummary) {
          this._roundSummary.printToConsole();
          this._roundSummary.writeToLog();
        }
        return;
      }

      // 2. å¤„ç†æ¯ä¸ªä»£å¸
      for (const token of tokens) {
        await this._processToken(token);
      }

      // 3. æ¸…ç†è¿‡æœŸä»£å¸
      const removed = this._tokenPool.cleanup();
      if (removed.length > 0) {
        this.logger.info(this._experimentId, 'MonitoringCycle',
          `æ¸…ç†è¿‡æœŸä»£å¸: ${removed.length} ä¸ª`);
      }

      // 4. è®°å½•æŠ•èµ„ç»„åˆæ€»è§ˆ
      if (this._roundSummary) {
        const portfolio = this._buildPortfolioSummary();
        this._roundSummary.recordPortfolio(portfolio);
      }

      // 5. è¾“å‡ºè½®æ¬¡æ‘˜è¦
      if (this._roundSummary) {
        this._roundSummary.printToConsole();
        this._roundSummary.writeToLog();
      }

      const duration = Date.now() - startTime;
      this.logger.info(this._experimentId, 'MonitoringCycle',
        `ç¬¬ ${this._loopCount} è½®ç›‘æ§å®Œæˆï¼Œè€—æ—¶: ${duration}ms`);

    } catch (error) {
      this.logger.error(this._experimentId, 'MonitoringCycle',
        `ç›‘æ§å¾ªç¯å¤±è´¥: ${error.message}`, { error: error.stack });
    }
  }

  /**
   * å¤„ç†å•ä¸ªä»£å¸
   * @private
   * @param {Object} token - ä»£å¸æ•°æ®
   * @returns {Promise<void>}
   */
  async _processToken(token) {
    try {
      this.logger.debug(this._experimentId, 'ProcessToken',
        `å¤„ç†ä»£å¸: ${token.symbol} (${token.status})`);

      // 1. è·å–Kçº¿æ•°æ®
      const klineData = await this._fetchKlineData(token);
      if (!klineData || klineData.length === 0) {
        this.logger.warn(this._experimentId, 'ProcessToken',
          `æ— æ³•è·å– ${token.symbol} çš„Kçº¿æ•°æ®`);
        return;
      }

      this.logger.debug(this._experimentId, 'ProcessToken',
        `${token.symbol} Kçº¿æ•°æ®: ${klineData.length} æ¡`);

      // 2. æ›´æ–°TokenPoolä¸­çš„Kçº¿æ•°æ®
      this._tokenPool.updateKlineData(
        token.token,
        token.chain,
        klineData
      );

      // 3. æ„å»ºå› å­ç»“æœ
      const factorResults = this._buildFactors(token, klineData);

      // è®°å½•ä»£å¸æŒ‡æ ‡åˆ° RoundSummary
      if (this._roundSummary) {
        const currentPrice = factorResults.currentPrice || token.currentPrice;
        this._roundSummary.recordTokenIndicators(
          token.token,
          token.symbol,
          {
            type: 'factor-based',
            factorCount: Object.keys(factorResults).length,
            strategyCount: this._strategyEngine.getStrategyCount(),
            factorValues: factorResults,
            triggeredStrategy: null // å°†åœ¨ç­–ç•¥è§¦å‘æ—¶æ›´æ–°
          },
          currentPrice
        );
      }

      // 4. ç­–ç•¥åˆ†æ
      const strategy = this._strategyEngine.evaluate(
        factorResults,
        token.token,
        Date.now()
      );

      if (strategy) {
        this.logger.info(this._experimentId, 'ProcessToken',
          `${token.symbol} è§¦å‘ç­–ç•¥: ${strategy.name} (${strategy.action})`);

        // è®°å½•ä¿¡å·åˆ° RoundSummary
        if (this._roundSummary) {
          this._roundSummary.recordSignal(token.token, {
            direction: strategy.action.toUpperCase(),
            action: strategy.action,
            confidence: 80,
            reason: strategy.name
          });

          // æ›´æ–°è§¦å‘ç­–ç•¥ä¿¡æ¯
          const tokenData = this._roundSummary.getRoundData()?.tokens?.find(t => t.address === token.token);
          if (tokenData && tokenData.indicators) {
            tokenData.indicators.triggeredStrategy = strategy;
          }
        }

        // 5. æ‰§è¡Œäº¤æ˜“
        const executed = await this._executeStrategy(strategy, token, klineData);

        // è®°å½•æ‰§è¡ŒçŠ¶æ€
        if (this._roundSummary) {
          this._roundSummary.recordSignalExecution(
            token.token,
            executed,
            executed ? null : 'æ‰§è¡Œå¤±è´¥'
          );
        }
      }

      // è®°å½•æŒä»“ä¿¡æ¯ï¼ˆå¦‚æœæœ‰ï¼‰
      if (this._roundSummary && token.status === 'bought') {
        const holding = this.holdings.get(token.token);
        if (holding) {
          this._roundSummary.recordPosition(token.token, {
            symbol: token.symbol,
            amount: holding.amount,
            buyPrice: holding.avgBuyPrice,
            currentPrice: factorResults.currentPrice || token.currentPrice
          });
        }
      }

    } catch (error) {
      this.logger.error(this._experimentId, 'ProcessToken',
        `å¤„ç†ä»£å¸ ${token.symbol} å¤±è´¥: ${error.message}`);
    }
  }

  /**
   * è·å–ä»£å¸Kçº¿æ•°æ®
   * @private
   * @param {Object} token - ä»£å¸æ•°æ®
   * @returns {Promise<Array>} Kçº¿æ•°æ®
   */
  async _fetchKlineData(token) {
    try {
      // æ„å»º tokenIdï¼Œæ ¼å¼ä¸º address-chain
      const tokenId = `${token.token}-${token.chain}`;
      const interval = 1; // 1åˆ†é’ŸKçº¿
      const limit = config.monitor?.klineLimit || 35;

      // è®¡ç®—ä»£å¸å¹´é¾„ï¼ˆåˆ†é’Ÿï¼‰
      const tokenAge = (Date.now() - token.createdAt * 1000) / 1000 / 60;

      this.logger.debug('å¼€å§‹è·å–Kçº¿æ•°æ®', {
        symbol: token.symbol,
        address: token.token?.substring(0, 8) + '...',
        chain: token.chain,
        tokenAge: `${tokenAge.toFixed(2)}åˆ†é’Ÿ`,
        interval: interval,
        limit: limit
      });

      const result = await this._aveApi.getKlineDataByToken(tokenId, interval, limit);

      this.logger.debug('AVE APIè¿”å›', {
        symbol: token.symbol,
        totalCount: result.total_count || 0,
        pointsCount: result.points?.length || 0,
        rawPoint: result.points?.[0]
      });

      if (!result.points || result.points.length === 0) {
        this.logger.debug('Kçº¿æ•°æ®ä¸ºç©º', {
          symbol: token.symbol,
          tokenAge: `${tokenAge.toFixed(2)}åˆ†é’Ÿ`
        });
        return [];
      }

      // æ£€æŸ¥ç¬¬ä¸€ä¸ªæ•°æ®ç‚¹çš„æ ¼å¼
      const firstPoint = result.points[0];
      const isArrayFormat = Array.isArray(firstPoint);
      this.logger.debug('Kçº¿æ•°æ®æ ¼å¼', {
        symbol: token.symbol,
        isArrayFormat: isArrayFormat,
        firstPointKeys: !isArrayFormat ? Object.keys(firstPoint) : 'N/A'
      });

      // æ ¼å¼åŒ–Kçº¿æ•°æ®
      const formattedData = AveKlineAPI.formatKlinePoints(result.points);

      this.logger.debug('Kçº¿æ•°æ®æ ¼å¼åŒ–å®Œæˆ', {
        symbol: token.symbol,
        originalCount: result.points.length,
        formattedCount: formattedData.length
      });

      if (formattedData.length === 0) {
        this.logger.debug('Kçº¿æ ¼å¼åŒ–ä¸ºç©º', {
          symbol: token.symbol,
          reason: 'æ•°æ®ç‚¹æ ¼å¼ä¸åŒ¹é…æˆ–è¢«è¿‡æ»¤'
        });
        return [];
      }

      return formattedData;

    } catch (error) {
      this.logger.debug('è·å–Kçº¿å¼‚å¸¸', {
        symbol: token.symbol,
        error: error.message
      });
      return [];
    }
  }

  /**
   * æ„å»ºç­–ç•¥å› å­
   * @private
   * @param {Object} token - ä»£å¸æ•°æ®
   * @param {Array} klineData - Kçº¿æ•°æ®
   * @returns {Object} å› å­ç»“æœ
   */
  _buildFactors(token, klineData) {
    const now = Date.now();

    // è·å–å½“å‰ä»·æ ¼ï¼šä¼˜å…ˆä½¿ç”¨Kçº¿æ•°æ®ï¼Œå¦åˆ™ä½¿ç”¨AVE APIè¿”å›çš„ä»·æ ¼
    let currentPrice = 0;
    if (klineData && klineData.length > 0) {
      const latestKline = klineData[klineData.length - 1];
      currentPrice = latestKline.close;
    } else if (token.currentPrice && token.currentPrice > 0) {
      // ä½¿ç”¨AVE APIè¿”å›çš„å½“å‰ä»·æ ¼
      currentPrice = token.currentPrice;
    }

    // è®¡ç®—ä»£å¸å¹´é¾„ï¼ˆåˆ†é’Ÿï¼‰
    const age = (now - token.createdAt * 1000) / 1000 / 60;

    // è®¡ç®—æŒä»“æ—¶é•¿ï¼ˆç§’ï¼‰
    const holdDuration = token.buyTime ? (now - token.buyTime) / 1000 : 0;

    // è®¡ç®—ç›ˆåˆ©ç™¾åˆ†æ¯”
    let profitPercent = 0;
    if (token.buyPrice && token.buyPrice > 0 && currentPrice > 0) {
      profitPercent = ((currentPrice - token.buyPrice) / token.buyPrice) * 100;
    }

    // è®¡ç®—RSIæŒ‡æ ‡ï¼ˆéœ€è¦è¶³å¤Ÿçš„Kçº¿æ•°æ®ï¼‰
    let rsi = 50; // é»˜è®¤å€¼
    if (klineData && klineData.length >= this._rsiIndicator.getRequiredDataPoints()) {
      rsi = this._rsiIndicator.calculateFromKline(klineData);
    }

    const factors = {
      age: age,
      currentPrice: currentPrice,
      buyPrice: token.buyPrice || null,
      holdDuration: holdDuration,
      profitPercent: profitPercent,
      rsi: rsi
    };

    this.logger.debug('ç­–ç•¥å› å­', {
      symbol: token.symbol,
      hasKline: klineData.length > 0,
      priceSource: klineData.length > 0 ? 'kline' : (currentPrice > 0 ? 'ave_api' : 'none'),
      currentPrice: currentPrice,
      age: `${age.toFixed(2)}åˆ†é’Ÿ`
    });

    return factors;
  }

  /**
   * æ‰§è¡Œç­–ç•¥
   * @private
   * @param {Object} strategy - ç­–ç•¥å¯¹è±¡
   * @param {Object} token - ä»£å¸æ•°æ®
   * @param {Array} klineData - Kçº¿æ•°æ®
   * @returns {Promise<boolean>} æ˜¯å¦æ‰§è¡ŒæˆåŠŸ
   */
  async _executeStrategy(strategy, token, klineData) {
    const latestKline = klineData[klineData.length - 1];
    const latestPrice = latestKline ? latestKline.close : 0;

    if (strategy.action === 'buy') {
      // åªå¯¹ç›‘æ§ä¸­çš„ä»£å¸æ‰§è¡Œä¹°å…¥
      if (token.status !== 'monitoring') {
        this.logger.debug(this._experimentId, 'ExecuteStrategy',
          `è·³è¿‡ä¹°å…¥: ${token.symbol} çŠ¶æ€ä¸º ${token.status}`);
        return false;
      }

      // æ‰§è¡Œä¹°å…¥
      const signal = {
        action: 'buy',
        symbol: token.symbol,
        tokenAddress: token.token,
        price: latestPrice,
        confidence: 80,
        reason: strategy.name
      };

      const result = await this.processSignal(signal);

      if (result && result.success) {
        // æ ‡è®°ä¸ºå·²ä¹°å…¥
        this._tokenPool.markAsBought(token.token, token.chain, {
          buyPrice: latestPrice,
          buyTime: Date.now()
        });

        // åŒæ­¥æ›´æ–°æŒä»“
        const holding = this.holdings.get(token.token);
        if (holding) {
          holding.avgBuyPrice = latestPrice;
        }

        return true;
      }

      return false;

    } else if (strategy.action === 'sell') {
      // åªå¯¹å·²ä¹°å…¥çš„ä»£å¸æ‰§è¡Œå–å‡º
      if (token.status !== 'bought') {
        this.logger.debug(this._experimentId, 'ExecuteStrategy',
          `è·³è¿‡å–å‡º: ${token.symbol} çŠ¶æ€ä¸º ${token.status}`);
        return false;
      }

      // æ‰§è¡Œå–å‡º
      const signal = {
        action: 'sell',
        symbol: token.symbol,
        tokenAddress: token.token,
        price: latestPrice,
        confidence: 80,
        reason: strategy.name
      };

      const result = await this.processSignal(signal);

      if (result && result.success) {
        // æ ‡è®°ä¸ºå·²é€€å‡º
        this._tokenPool.markAsExited(token.token, token.chain);
        return true;
      }

      return false;
    }

    return false;
  }

  /**
   * æ„å»ºç­–ç•¥é…ç½®
   * @private
   * @returns {Array} ç­–ç•¥é…ç½®æ•°ç»„
   */
  _buildStrategyConfig() {
    const strategyConfig = config.strategy || {};

    return [
      {
        id: 'early_return_buy',
        name: 'æ—©æ­¢ä¹°å…¥',
        action: 'buy',
        priority: 1,
        cooldown: 60,
        enabled: true,
        condition: 'age < buyTimeMinutes AND currentPrice > 0'
      },
      {
        id: 'take_profit_1',
        name: 'æ­¢ç›ˆ1 (30%å–å‡º50%)',
        action: 'sell',
        priority: 1,
        cooldown: 30,
        enabled: true,
        condition: 'profitPercent >= takeProfit1 AND holdDuration > 0'
      },
      {
        id: 'take_profit_2',
        name: 'æ­¢ç›ˆ2 (50%å…¨éƒ¨å–å‡º)',
        action: 'sell',
        priority: 2,
        cooldown: 30,
        enabled: true,
        condition: 'profitPercent >= takeProfit2 AND holdDuration > 0'
      },
      {
        id: 'stop_loss',
        name: 'æ—¶é—´æ­¢æŸ',
        action: 'sell',
        priority: 10,
        cooldown: 60,
        enabled: true,
        condition: 'holdDuration >= stopLossMinutes * 60 AND profitPercent <= 0'
      }
    ];
  }

  /**
   * å¤„ç†ç­–ç•¥ä¿¡å·
   * @param {Object} signal - ç­–ç•¥ä¿¡å·
   * @returns {Promise<Object>} å¤„ç†ç»“æœ
   */
  async processSignal(signal) {
    if (this._status !== EngineStatus.RUNNING) {
      console.warn('âš ï¸ å¼•æ“æœªè¿è¡Œï¼Œå¿½ç•¥ä¿¡å·');
      return { executed: false, reason: 'å¼•æ“æœªè¿è¡Œ' };
    }

    this.metrics.totalSignals++;

    // è®°å½•ä¿¡å·åˆ°æ•°æ®åº“
    const tradeSignal = TradeSignal.fromStrategySignal(signal, this._experimentId);
    await this.dataService.saveSignal(tradeSignal);

    console.log(`ğŸ“Š æ”¶åˆ°ä¿¡å·: ${signal.action} ${signal.symbol} (${signal.tokenAddress})`);
    console.log(`   åŸå› : ${signal.reason}`);
    console.log(`   ç½®ä¿¡åº¦: ${signal.confidence}%`);

    // æ ¹æ®ä¿¡å·ç±»å‹æ‰§è¡Œäº¤æ˜“
    let tradeResult = null;
    if (signal.action === 'buy') {
      tradeResult = await this._executeBuy(signal);
    } else if (signal.action === 'sell') {
      tradeResult = await this._executeSell(signal);
    } else {
      console.log(`â„¹ï¸ å¿½ç•¥ hold ä¿¡å·: ${signal.symbol}`);
      return { executed: false, reason: 'holdä¿¡å·' };
    }

    if (tradeResult && tradeResult.success) {
      this.metrics.executedSignals++;
    }

    return tradeResult;
  }

  /**
   * æ‰§è¡Œä¹°å…¥äº¤æ˜“
   * @param {Object} signal - ä¹°å…¥ä¿¡å·
   * @returns {Promise<Object>} äº¤æ˜“ç»“æœ
   * @private
   */
  async _executeBuy(signal) {
    try {
      const amountInBNB = this._calculateBuyAmount(signal);
      if (amountInBNB <= 0) {
        return { success: false, reason: 'ä½™é¢ä¸è¶³æˆ–è®¡ç®—é‡‘é¢ä¸º0' };
      }

      const price = signal.price || signal.buyPrice || 0;
      const tokenAmount = price > 0 ? amountInBNB / price : 0;

      const tradeRequest = {
        tokenAddress: signal.tokenAddress,
        symbol: signal.symbol,
        direction: 'buy',
        amount: tokenAmount,
        price: price
      };

      const result = await this.executeTrade(tradeRequest);

      if (result.success) {
        console.log(`âœ… ä¹°å…¥æˆåŠŸ: ${signal.symbol} æ•°é‡=${tokenAmount.toFixed(6)}, ä»·æ ¼=${price}`);
      }

      return result;

    } catch (error) {
      console.error(`âŒ ä¹°å…¥å¤±è´¥: ${error.message}`);
      return { success: false, reason: error.message };
    }
  }

  /**
   * æ‰§è¡Œå–å‡ºäº¤æ˜“
   * @param {Object} signal - å–å‡ºä¿¡å·
   * @returns {Promise<Object>} äº¤æ˜“ç»“æœ
   * @private
   */
  async _executeSell(signal) {
    try {
      const holding = this.holdings.get(signal.tokenAddress);
      if (!holding || holding.amount <= 0) {
        return { success: false, reason: 'æ— æŒä»“' };
      }

      // å–å‡ºå…¨éƒ¨æŒä»“
      const amountToSell = holding.amount;
      const price = signal.price || 0;
      const amountOutBNB = price > 0 ? amountToSell * price : 0;

      const tradeRequest = {
        tokenAddress: signal.tokenAddress,
        symbol: signal.symbol,
        direction: 'sell',
        amount: amountToSell,
        price: price
      };

      const result = await this.executeTrade(tradeRequest);

      if (result.success) {
        console.log(`âœ… å–å‡ºæˆåŠŸ: ${signal.symbol} æ•°é‡=${amountToSell.toFixed(6)}, æ”¶å…¥=${amountOutBNB.toFixed(4)} BNB`);
      }

      return result;

    } catch (error) {
      console.error(`âŒ å–å‡ºå¤±è´¥: ${error.message}`);
      return { success: false, reason: error.message };
    }
  }

  /**
   * è®¡ç®—ä¹°å…¥é‡‘é¢
   * @param {Object} signal - ä¿¡å·
   * @returns {number} BNBé‡‘é¢
   * @private
   */
  _calculateBuyAmount(signal) {
    // é»˜è®¤æ¯æ¬¡ä½¿ç”¨å½“å‰ä½™é¢çš„10%
    const tradeRatio = this._experiment.config?.virtual?.tradeRatio || 0.1;
    const amount = this.currentBalance * tradeRatio;

    // æœ€å°äº¤æ˜“é‡‘é¢ 0.001 BNB
    return Math.max(amount, 0.001);
  }

  /**
   * æ‰§è¡Œäº¤æ˜“
   * @param {Object} tradeRequest - äº¤æ˜“è¯·æ±‚
   * @returns {Promise<Object>} äº¤æ˜“ç»“æœ
   */
  async executeTrade(tradeRequest) {
    this.metrics.totalTrades++;

    const trade = Trade.fromVirtualTrade({
      tokenAddress: tradeRequest.tokenAddress,
      symbol: tradeRequest.symbol,
      chain: this._experiment.blockchain || 'bsc',
      direction: tradeRequest.direction,
      amount: tradeRequest.amount,
      price: tradeRequest.price,
      success: false, // å…ˆè®¾ç½®ä¸ºfalseï¼Œæ‰§è¡ŒæˆåŠŸåå†æ›´æ–°
      error: null
    }, this._experimentId);

    try {
      if (tradeRequest.direction === 'buy') {
        await this._processBuy(trade);
      } else if (tradeRequest.direction === 'sell') {
        await this._processSell(trade);
      }

      trade.markAsSuccess();
      this.metrics.successfulTrades++;

      // ä¿å­˜äº¤æ˜“è®°å½•
      await this.dataService.saveTrade(trade);

      return {
        success: true,
        trade: trade.toJSON(),
        balance: this.currentBalance,
        holdings: Array.from(this.holdings.entries())
      };

    } catch (error) {
      trade.markAsFailed(error.message);
      this.metrics.failedTrades++;

      // ä¿å­˜å¤±è´¥äº¤æ˜“è®°å½•
      await this.dataService.saveTrade(trade);

      return {
        success: false,
        error: error.message,
        trade: trade.toJSON()
      };
    }
  }

  /**
   * å¤„ç†ä¹°å…¥
   * @param {Trade} trade - äº¤æ˜“å®ä½“
   * @private
   */
  async _processBuy(trade) {
    const cost = parseFloat(trade.price) * parseFloat(trade.amount);
    const costWithFee = cost * 1.001; // 0.1% æ‰‹ç»­è´¹

    if (costWithFee > this.currentBalance) {
      throw new Error(`ä½™é¢ä¸è¶³: éœ€è¦ ${costWithFee.toFixed(4)} BNB, å¯ç”¨ ${this.currentBalance.toFixed(4)} BNB`);
    }

    // æ‰£é™¤ä½™é¢
    this.currentBalance -= costWithFee;

    // æ›´æ–°æŒä»“
    const holding = this.holdings.get(trade.tokenAddress) || { amount: 0, avgBuyPrice: 0 };
    const totalCost = holding.amount * holding.avgBuyPrice + cost;
    holding.amount += parseFloat(trade.amount);
    holding.avgBuyPrice = totalCost / holding.amount;
    this.holdings.set(trade.tokenAddress, holding);

    console.log(`ğŸ’° ä¹°å…¥æ‰§è¡Œ: ${trade.tokenSymbol} ${trade.amount.toFixed(6)} @ ${trade.price}, è€—è´¹ ${costWithFee.toFixed(4)} BNB`);
    console.log(`   å½“å‰ä½™é¢: ${this.currentBalance.toFixed(4)} BNB`);
  }

  /**
   * å¤„ç†å–å‡º
   * @param {Trade} trade - äº¤æ˜“å®ä½“
   * @private
   */
  async _processSell(trade) {
    const revenue = parseFloat(trade.price) * parseFloat(trade.amount);
    const revenueWithFee = revenue * 0.999; // 0.1% æ‰‹ç»­è´¹

    // å¢åŠ ä½™é¢
    this.currentBalance += revenueWithFee;

    // æ›´æ–°æŒä»“
    const holding = this.holdings.get(trade.tokenAddress);
    if (holding) {
      holding.amount -= parseFloat(trade.amount);
      if (holding.amount <= 0.000001) {
        this.holdings.delete(trade.tokenAddress);
      } else {
        this.holdings.set(trade.tokenAddress, holding);
      }
    }

    // è®¡ç®—ç›ˆäº
    const pnl = revenue - (holding.avgBuyPrice * parseFloat(trade.amount));
    const pnlPercentage = (pnl / (holding.avgBuyPrice * parseFloat(trade.amount))) * 100;

    console.log(`ğŸ’° å–å‡ºæ‰§è¡Œ: ${trade.tokenSymbol} ${trade.amount.toFixed(6)} @ ${trade.price}, æ”¶å…¥ ${revenueWithFee.toFixed(4)} BNB`);
    console.log(`   ç›ˆäº: ${pnl.toFixed(4)} BNB (${pnlPercentage.toFixed(2)}%)`);
    console.log(`   å½“å‰ä½™é¢: ${this.currentBalance.toFixed(4)} BNB`);
  }

  /**
   * åŠ è½½æŒä»“æ•°æ®
   * @private
   */
  async _loadHoldings() {
    try {
      const trades = await this.dataService.getTrades(this._experimentId, {
        limit: 10000
      });

      // é‡ç½®æŒä»“
      this.holdings.clear();
      this.currentBalance = this.initialBalance;

      // æŒ‰æ—¶é—´é¡ºåºé‡æ”¾äº¤æ˜“
      for (const trade of trades.sort((a, b) => a.createdAt - b.createdAt)) {
        if (!trade.success) continue;

        if (trade.direction === 'buy') {
          const cost = parseFloat(trade.price) * parseFloat(trade.amount) * 1.001;
          this.currentBalance -= cost;

          const holding = this.holdings.get(trade.tokenAddress) || { amount: 0, avgBuyPrice: 0 };
          const totalCost = holding.amount * holding.avgBuyPrice + cost;
          holding.amount += parseFloat(trade.amount);
          holding.avgBuyPrice = totalCost / holding.amount;
          this.holdings.set(trade.tokenAddress, holding);

        } else if (trade.direction === 'sell') {
          const revenue = parseFloat(trade.price) * parseFloat(trade.amount) * 0.999;
          this.currentBalance += revenue;

          const holding = this.holdings.get(trade.tokenAddress);
          if (holding) {
            holding.amount -= parseFloat(trade.amount);
            if (holding.amount <= 0.000001) {
              this.holdings.delete(trade.tokenAddress);
            }
          }
        }
      }

      console.log(`ğŸ“¦ æŒä»“åŠ è½½å®Œæˆ: ${this.holdings.size} ä¸ªä»£å¸, ä½™é¢ ${this.currentBalance.toFixed(4)} BNB`);

    } catch (error) {
      console.error('âŒ åŠ è½½æŒä»“å¤±è´¥:', error.message);
    }
  }

  /**
   * è·å–çŠ¶æ€
   * @returns {string}
   */
  getStatus() {
    return this._status;
  }

  /**
   * è·å–æŒ‡æ ‡
   * @returns {Object}
   */
  getMetrics() {
    const profit = this.currentBalance - this.initialBalance;
    const profitRate = (profit / this.initialBalance) * 100;

    return {
      ...this.metrics,
      initialBalance: this.initialBalance,
      currentBalance: this.currentBalance,
      profit: profit,
      profitRate: profitRate,
      holdingsCount: this.holdings.size,
      holdings: Array.from(this.holdings.entries()).map(([addr, h]) => ({
        tokenAddress: addr,
        amount: h.amount,
        avgBuyPrice: h.avgBuyPrice
      }))
    };
  }

  /**
   * ä¿å­˜è¿è¡Œæ—¶æŒ‡æ ‡
   * @param {string} metricName - æŒ‡æ ‡åç§°
   * @param {number} metricValue - æŒ‡æ ‡å€¼
   */
  async saveMetric(metricName, metricValue) {
    await this.dataService.saveRuntimeMetric(
      this._experimentId,
      metricName,
      metricValue,
      { timestamp: new Date().toISOString() }
    );
  }

  /**
   * æ„å»ºæŠ•èµ„ç»„åˆæ‘˜è¦
   * @private
   * @returns {Object} æŠ•èµ„ç»„åˆæ•°æ®
   */
  _buildPortfolioSummary() {
    // è®¡ç®—æ€»ä»·å€¼
    let totalValue = this.currentBalance;
    const positions = [];

    for (const [tokenAddress, holding] of this.holdings.entries()) {
      if (holding.amount > 0) {
        // è·å–å½“å‰ä»·æ ¼ï¼ˆä»æŒä»“æˆ– token poolï¼‰
        let currentPrice = holding.avgBuyPrice; // é»˜è®¤ä½¿ç”¨ä¹°å…¥ä»·
        const token = this._tokenPool.getToken(tokenAddress, 'bsc');
        if (token && token.currentPrice) {
          currentPrice = token.currentPrice;
        }

        const value = holding.amount * currentPrice;
        totalValue += value;

        positions.push({
          symbol: token?.symbol || 'UNKNOWN',
          amount: holding.amount,
          value: value,
          buyPrice: holding.avgBuyPrice,
          currentPrice: currentPrice
        });
      }
    }

    return {
      totalValue: totalValue,
      cashBalance: this.currentBalance,
      positions: positions
    };
  }
}
    await this.dataService.saveRuntimeMetric(
      this._experimentId,
      metricName,
      metricValue,
      { timestamp: new Date().toISOString() }
    );
  }
}

module.exports = { VirtualTradingEngine };
